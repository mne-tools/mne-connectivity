# Authors: Adam Li <adam2392@gmail.com>
#          Santeri Ruuskanen <santeriruuskanen@gmail.com>
#
# License: BSD (3-clause)
import mne.filter
import numpy as np
import scipy.signal as signal
from mne.epochs import BaseEpochs
from mne.parallel import parallel_func
from mne.utils import (logger, warn)

from ..base import (SpectralConnectivity, EpochSpectralConnectivity)
from ..utils import check_indices, fill_doc


@fill_doc
def spectral_connectivity_time_hilbert(data, names=None, method='coh',
                                       average=False, indices=None,
                                       sfreq=2 * np.pi, fmin=None,
                                       fmax=None, decim=1, n_jobs=1,
                                       verbose=None):
    """Compute frequency- and time-frequency-domain connectivity measures.

    This method computes time-resolved connectivity measures from epoched data.

    The connectivity method(s) are specified using the "method" parameter.
    All methods are based on estimates of the cross- and power spectral
    densities (CSD/PSD) Sxy and Sxx, Syy.

    Parameters
    ----------
    data : array_like, shape (n_epochs, n_signals, n_times) | Epochs
        The data from which to compute connectivity.
    %(names)s
    method : str | list of str
        Connectivity measure(s) to compute. These can be ``['coh', 'plv',
        'sxy', 'pli', 'wpli']``. These are:

            * 'coh' : Coherence
            * 'plv' : Phase-Locking Value (PLV)
            * 'sxy' : Cross-spectrum
            * 'pli' : Phase-Lag Index
            * 'wpli': Weighted Phase-Lag Index

        By default, coherence is used.
    average : bool
        Average connectivity scores over epochs. If True, output will be
        an instance of ``SpectralConnectivity`` , otherwise
        ``EpochSpectralConnectivity``. By default, False.
    indices : tuple of array | None
        Two arrays with indices of connections for which to compute
        connectivity. I.e. it is a ``(n_pairs, 2)`` array essentially.
        If None, all connections are computed.
    sfreq : float
        The sampling frequency. Should be specified if data is not ``Epochs``.
    fmin : float | tuple of float | None
        The lower frequency of interest. Multiple bands are defined using
        a tuple, e.g., (8., 20.) for two bands with 8Hz and 20Hz lower freq.
        If None, the frequency corresponding to an epoch length of 5 cycles
        is used.
    fmax : float | tuple of float | None
        The upper frequency of interest. Multiple bands are defined using
        a tuple, e.g. (13., 30.) for two band with 13Hz and 30Hz upper freq.
        If None, sfreq/2 is used.
    decim : int
        To reduce memory usage, decimation factor after time-frequency
        decomposition. default 1 If int, returns tfr[…, ::decim]. If slice,
        returns tfr[…, decim].
    n_jobs : int
        Number of connections to compute in parallel. Memory mapping must be
        activated. Please see the Notes section for details.
    %(verbose)s

    Returns
    -------
    con : instance of Connectivity | list
        Computed connectivity measure(s). An instance of
        ``EpochSpectralConnectivity``, ``SpectralConnectivity``
        or a list of instances corresponding to connectivity measures if
        several connectivity measures are specified.
        The shape of each connectivity dataset is
        (n_epochs, n_signals, n_signals, n_freqs) when indices is None
        and (n_epochs, n_nodes, n_nodes, n_freqs) when "indices" is specified
        and "n_nodes = len(indices[0])".

    See Also
    --------
    mne_connectivity.spectral_connectivity_epochs
    mne_connectivity.SpectralConnectivity
    mne_connectivity.EpochSpectralConnectivity

    Notes
    -----

    Please note that the interpretation of the measures in this function
    depends on the data and underlying assumptions and does not necessarily
    reflect a causal relationship between brain regions.

    The connectivity measures are computed over time within each epoch and
    optionally averaged over epochs. High connectivity values indicate that
    the phase differences between signals stay consistent over time.

    The spectral densities are estimated using analytic signal generated by
    FIR filtering and Hilbert transforming the data.

    By default, the connectivity between all signals is computed (only
    connections corresponding to the lower-triangular part of the
    connectivity matrix). If one is only interested in the connectivity
    between some signals, the "indices" parameter can be used. For example,
    to compute the connectivity between the signal with index 0 and signals
    "2, 3, 4" (a total of 3 connections) one can use the following::

        indices = (np.array([0, 0, 0]),    # row indices
                   np.array([2, 3, 4]))    # col indices

        con = spectral_connectivity_time(data, method='coh',
                                         indices=indices, ...)

    In this case con.get_data().shape = (3, n_freqs). The connectivity scores
    are in the same order as defined indices.

    **Supported Connectivity Measures**

    The connectivity method(s) is specified using the "method" parameter. The
    following methods are supported (note: ``E[]`` denotes average over
    epochs). Multiple measures can be computed at once by using a list/tuple,
    e.g., ``['coh', 'pli']`` to compute coherence and PLI.

        'coh' : Coherence given by::

                     | E[Sxy] |
            C = ---------------------
                sqrt(E[Sxx] * E[Syy])

        'plv' : Phase-Locking Value (PLV) :footcite:`LachauxEtAl1999` given
        by::

            PLV = |E[Sxy/|Sxy|]|

        'ciplv' : corrected imaginary PLV (icPLV)
        :footcite:`BrunaEtAl2018` given by::

                             |E[Im(Sxy/|Sxy|)]|
            ciPLV = ------------------------------------
                     sqrt(1 - |E[real(Sxy/|Sxy|)]| ** 2)

        'sxy' : Cross spectrum Sxy

        'pli' : Phase Lag Index (PLI) :footcite:`StamEtAl2007` given by::

            PLI = |E[sign(Im(Sxy))]|

        'wpli' : Weighted Phase Lag Index (WPLI) :footcite:`VinckEtAl2011`
        given by::

                      |E[Im(Sxy)]|
            WPLI = ------------------
                      E[|Im(Sxy)|]

    Parallel computation can be activated by setting the ``n_jobs`` parameter.
    Under the hood, this utilizes the ``joblib`` library. For effective
    parallelization, you should activate memory mapping in MNE-Python by
    setting ``MNE_MEMMAP_MIN_SIZE`` and ``MNE_CACHE_DIR``. For example, in your
    code, run
    ```
    mne.set_config('MNE_MEMMAP_MIN_SIZE', '10M')
    mne.set_config('MNE_CACHE_DIR', '/dev/shm')
    ```

    This function was originally implemented in ``frites`` and was
    ported over.

    .. versionadded:: 0.3

    References
    ----------
    .. footbibliography::
    """
    events = None
    event_id = None
    # extract data from Epochs object
    if isinstance(data, BaseEpochs):
        names = data.ch_names
        sfreq = data.info['sfreq']
        events = data.events
        event_id = data.event_id
        n_epochs, n_signals, n_times = data.get_data().shape
        # Extract metadata from the Epochs data structure.
        # Make Annotations persist through by adding them to the metadata.
        metadata = data.metadata
        if metadata is None:
            annots_in_metadata = False
        else:
            annots_in_metadata = all(
                name not in metadata.columns for name in [
                    'annot_onset', 'annot_duration', 'annot_description'])
        if hasattr(data, 'annotations') and not annots_in_metadata:
            data.add_annotations_to_metadata(overwrite=True)
        metadata = data.metadata
        data = data.get_data()
    else:
        data = np.asarray(data)
        n_epochs, n_signals, n_times = data.shape
        names = np.arange(0, n_signals)
        metadata = None
        if sfreq is None:
            warn("Sampling frequency (sfreq) was not specified and could not "
                 "be inferred from data. Using default value 2*numpy.pi. "
                 "Connectivity results might not be interpretable.")

    # check that method is a list
    if isinstance(method, str):
        method = [method]

    # check that fmin corresponds to at least 5 cycles
    dur = float(n_times) / sfreq
    five_cycle_freq = 5. / dur
    if fmin is None:
        # use the 5 cycle freq. as default
        fmin = five_cycle_freq
        logger.info(f'Fmin was not specified. Using fmin={fmin:.2f}, which '
                    'corresponds to at least five cycles.')
    else:
        if np.any(fmin < five_cycle_freq):
            warn('fmin=%0.3f Hz corresponds to %0.3f < 5 cycles '
                 'based on the epoch length %0.3f sec, need at least %0.3f '
                 'sec epochs or fmin=%0.3f. Spectrum estimate will be '
                 'unreliable.' % (np.min(fmin), dur * np.min(fmin), dur,
                                  5. / np.min(fmin), five_cycle_freq))
    if fmax is None:
        fmax = sfreq / 2
        logger.info(f'Fmax was not specified. Using fmax={fmax:.2f}, which '
                    f'corresponds to Nyquist.')

    fmin = np.array((fmin,), dtype=float).ravel()
    fmax = np.array((fmax,), dtype=float).ravel()
    if len(fmin) != len(fmax):
        raise ValueError('fmin and fmax must have the same length')
    if np.any(fmin > fmax):
        raise ValueError('fmax must be larger than fmin')

    # get indices of pairs of (group) regions
    if indices is None:
        indices_use = np.tril_indices(n_signals, k=-1)
    else:
        indices_use = check_indices(indices)
    source_idx = indices_use[0]
    target_idx = indices_use[1]
    n_pairs = len(source_idx)

    # compute central frequencies
    f_vec = np.mean(np.stack([fmin, fmax], axis=1), axis=1)
    out_freqs = f_vec
    n_freqs = len(f_vec)

    conn = dict()
    for m in method:
        conn[m] = np.zeros((n_epochs, n_pairs,  n_freqs))
    logger.info('Connectivity computation...')

    # parameters to pass to the connectivity function
    call_params = dict(
        method=method, source_idx=source_idx, target_idx=target_idx,
        sfreq=sfreq, fmin=fmin, fmax=fmax, decim=decim, n_jobs=n_jobs,
        verbose=verbose)

    for epoch_idx in np.arange(n_epochs):
        logger.info(f'   Processing epoch {epoch_idx+1} / {n_epochs} ...')
        conn_tr = _spectral_connectivity(data[epoch_idx], **call_params)
        for m in method:
            conn[m][epoch_idx] = np.stack(conn_tr[m], axis=0)

    if indices is None:
        conn_flat = conn
        conn = dict()
        for m in method:
            this_conn = np.zeros((n_epochs, n_signals, n_signals) +
                                 conn_flat[m].shape[2:],
                                 dtype=conn_flat[m].dtype)
            this_conn[:, source_idx, target_idx] = conn_flat[m]
            this_conn = this_conn.reshape((n_epochs, n_signals ** 2,) +
                                          conn_flat[m].shape[2:])
            conn[m] = this_conn

    # create a Connectivity container
    if average:
        out = [SpectralConnectivity(
               conn[m].mean(axis=0), freqs=out_freqs, n_nodes=n_signals,
               names=names, indices=indices, method=method,
               spec_method='hilbert', events=events, event_id=event_id,
               metadata=metadata)
               for m in method]
    else:
        out = [EpochSpectralConnectivity(
               conn[m], freqs=out_freqs, n_nodes=n_signals, names=names,
               indices=indices, method=method, spec_method='hilbert',
               events=events, event_id=event_id,
               metadata=metadata) for m in method]

    logger.info('[Connectivity computation done]')

    # return the object instead of list of length one
    if len(out) == 1:
        return out[0]
    else:
        return out


def _spectral_connectivity(data, method, source_idx, target_idx, sfreq, fmin,
                           fmax, decim=1, n_jobs=1, verbose=False):
    """Estimate time-resolved connectivity for one epoch.

    See spectral_connectivity_epochs."""
    n_pairs = len(source_idx)
    complex_signal = []
    for freq_min, freq_max in zip(fmin, fmax):
        filtered = mne.filter.filter_data(data, sfreq, l_freq=freq_min,
                                          h_freq=freq_max, verbose=verbose,
                                          n_jobs=n_jobs)
        hilb = signal.hilbert(filtered)
        hilb = hilb[..., ::decim] if type(decim) == int else hilb[..., decim]
        complex_signal.append(hilb)
    complex_signal = np.moveaxis(np.array(complex_signal), 0, 1)

    # compute for each connectivity method
    this_conn = {}
    conn = _parallel_con(complex_signal, method, source_idx, target_idx,
                         n_jobs, verbose, n_pairs)
    for i, m in enumerate(method):
        this_conn[m] = [out[i] for out in conn]

    return this_conn


###############################################################################
###############################################################################
#                               TIME-RESOLVED CORE FUNCTIONS
###############################################################################
###############################################################################

def _parallel_con(w, method, source_idx, target_idx, n_jobs, verbose, total):
    """Compute spectral connectivity in parallel.

    Input signal w is of shape (n_chans, n_freqs, n_times)."""

    if 'coh' in method:
        # auto spectra (faster than w * w.conj())
        s_auto = w.real ** 2 + w.imag ** 2

    def pairwise_con(w_x, w_y):
        s_xy = w[w_y] * np.conj(w[w_x])
        dphi = s_xy / np.abs(s_xy)
        out = []
        for m in method:
            if m == 'coh':
                s_xx = s_auto[w_x]
                s_yy = s_auto[w_y]
                coh = np.abs(s_xy.mean(axis=-1)) / \
                      np.sqrt(s_xx.mean(axis=-1) *
                              s_yy.mean(axis=-1))
                out.append(coh)

            if m == 'plv':
                dphi_mean = dphi.mean(axis=-1)
                plv = np.abs(dphi_mean)
                out.append(plv)

            if m == 'ciplv':
                rplv = np.abs(np.mean(np.real(dphi), axis=-1))
                iplv = np.abs(np.mean(np.imag(dphi), axis=-1))
                ciplv = iplv / (np.sqrt(1 - rplv ** 2))
                out.append(ciplv)

            if m == 'pli':
                pli = np.abs(np.mean(np.sign(np.imag(s_xy)),
                                     axis=-1))
                out.append(pli)

            if m == 'wpli':
                con_num = np.abs(s_xy.imag.mean(axis=-1))
                con_den = np.mean(np.abs(s_xy.imag), axis=-1)
                wpli = con_num / con_den
                out.append(wpli)

            if m == 'cs':
                out.append(s_xy)

        return out

    # define the function to compute in parallel
    parallel, p_fun, n_jobs = parallel_func(
        pairwise_con, n_jobs=n_jobs, verbose=verbose, total=total)

    return parallel(p_fun(s, t) for s, t in zip(source_idx, target_idx))
